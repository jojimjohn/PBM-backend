const express = require('express');
const { validate, validateParams, sanitize } = require('../middleware/validation');
const { requirePermission } = require('../middleware/auth');
const { logger, auditLog } = require('../utils/logger');
const { getDbConnection } = require('../config/database');
const { uploadMultiple, deleteFile, fileExists } = require('../middleware/upload');
const { createBatch } = require('../utils/fifoAllocator');
const path = require('path');
const Joi = require('joi');

const router = express.Router();

// Apply sanitization to all routes
router.use(sanitize);

// Helper function to format payment terms for display
const formatPaymentTermsForDisplay = (paymentTerms) => {
  const termsMap = {
    'immediate': 'Payment Terms: Immediate',
    'net_30': 'Payment Terms: Net 30 Days',
    'net_60': 'Payment Terms: Net 60 Days',
    'net_90': 'Payment Terms: Net 90 Days',
    'advance': 'Payment Terms: Advance Payment',
    'cod': 'Payment Terms: Cash on Delivery'
  };
  return termsMap[paymentTerms] || 'Payment Terms: Net 30 Days';
};

// Purchase order validation schema
const purchaseOrderSchema = Joi.object({
  orderNumber: Joi.string().optional(), // Generated by backend if not provided
  supplierId: Joi.number().integer().positive().required(),
  supplierName: Joi.string().allow('').optional(), // For display purposes, not stored
  orderDate: Joi.date().default(() => new Date()),
  expectedDeliveryDate: Joi.alternatives().try(Joi.date(), Joi.string().allow('').allow(null)).optional(),
  paymentTerms: Joi.string().valid('immediate', 'net_30', 'net_60', 'net_90', 'advance', 'cod').default('net_30'),
  status: Joi.string().valid('draft', 'pending', 'approved', 'sent', 'received', 'completed', 'cancelled').default('draft'),
  subtotal: Joi.number().min(0).precision(3).default(0),
  taxAmount: Joi.number().min(0).precision(3).default(0),
  totalAmount: Joi.number().min(0).precision(3).default(0),
  shippingCost: Joi.number().min(0).precision(3).default(0),
  notes: Joi.string().allow('').allow(null).optional(),
  branch_id: Joi.number().integer().positive().allow(null).optional(), // Branch ID for multi-branch support
  items: Joi.array().items(Joi.object({
    materialId: Joi.number().integer().positive().required(),
    // For drafts, quantity/rate/amount are optional; for other statuses they're required
    quantity: Joi.number().min(0.001).precision(3).optional().default(0),
    rate: Joi.number().min(0).precision(3).optional().default(0),
    amount: Joi.number().min(0).precision(3).optional().default(0)
  }).options({ stripUnknown: true })).optional()
}).options({ stripUnknown: true }).custom((value, helpers) => {
  // If not a draft, require quantity, rate, and amount for all items
  if (value.status !== 'draft' && value.items && value.items.length > 0) {
    for (const item of value.items) {
      if (!item.quantity || item.quantity <= 0) {
        return helpers.error('any.custom', { message: 'Quantity is required for non-draft orders' });
      }
      if (item.rate === undefined || item.rate === null) {
        return helpers.error('any.custom', { message: 'Rate is required for non-draft orders' });
      }
    }
  }
  return value;
});

// Purchase order item validation schema
const purchaseOrderItemSchema = Joi.object({
  purchaseOrderId: Joi.number().integer().positive().required(),
  materialId: Joi.number().integer().positive().required(),
  quantity: Joi.number().min(0.001).precision(3).required(),
  unitPrice: Joi.number().min(0).precision(3).required(),
  totalPrice: Joi.number().min(0).precision(3).required(),
  contractRate: Joi.number().min(0).precision(3).optional(),
  appliedRateType: Joi.string().valid('fixed_rate', 'discount_percentage', 'minimum_price_guarantee').optional(),
  contractSavings: Joi.number().min(0).precision(2).default(0),
  notes: Joi.string().allow('').optional()
});

// GET /api/purchase-orders - List all purchase orders
router.get('/', requirePermission('VIEW_PURCHASE'), async (req, res) => {
  try {
    const { companyId } = req.user;
    const db = getDbConnection(companyId);
    
    const {
      page = 1,
      limit = 50,
      search = '',
      supplierId = '',
      status = '',
      fromDate = '',
      toDate = ''
    } = req.query;

    const offset = (page - 1) * limit;
    
    let query = db('purchase_orders')
      .leftJoin('suppliers', 'purchase_orders.supplierId', 'suppliers.id')
      .leftJoin('collection_orders', 'purchase_orders.collection_order_id', 'collection_orders.id')
      .select(
        'purchase_orders.*',
        'suppliers.name as supplierName',
        'suppliers.specialization',
        'collection_orders.orderNumber as collectionOrderNumber',
        'collection_orders.wcn_number',
        db.raw('(SELECT COUNT(*) FROM purchase_order_items WHERE purchase_order_items.purchaseOrderId = purchase_orders.id) as itemCount')
      )
      .whereNot('purchase_orders.status', 'cancelled');

    // Search filter
    if (search) {
      query = query.where(function() {
        this.where('purchase_orders.orderNumber', 'like', `%${search}%`)
            .orWhere('suppliers.name', 'like', `%${search}%`)
            .orWhere('purchase_orders.notes', 'like', `%${search}%`);
      });
    }

    // Supplier filter
    if (supplierId) {
      query = query.where('purchase_orders.supplierId', supplierId);
    }

    // Status filter
    if (status) {
      query = query.where('purchase_orders.status', status);
    }

    // Date range filter
    if (fromDate) {
      query = query.where('purchase_orders.orderDate', '>=', fromDate);
    }
    if (toDate) {
      query = query.where('purchase_orders.orderDate', '<=', toDate);
    }

    // Get total count for pagination
    const totalQuery = query.clone();
    const [{ total }] = await totalQuery.count('* as total');

    // Get paginated results
    const orders = await query
      .orderBy('purchase_orders.orderDate', 'desc')
      .orderBy('purchase_orders.id', 'desc')
      .limit(limit)
      .offset(offset);

    // Convert DECIMAL strings to numbers for consistent JSON format
    const formattedOrders = orders.map(order => ({
      ...order,
      subtotal: parseFloat(order.subtotal) || 0,
      taxAmount: parseFloat(order.taxAmount) || 0,
      totalAmount: parseFloat(order.totalAmount) || 0,
      shippingCost: parseFloat(order.shippingCost) || 0
    }));

    // Log financial values from first order for debugging
    if (formattedOrders.length > 0) {
      logger.info('ðŸ’° Sample PO financial values from list:', {
        orderNumber: formattedOrders[0].orderNumber,
        subtotal: formattedOrders[0].subtotal,
        taxAmount: formattedOrders[0].taxAmount,
        totalAmount: formattedOrders[0].totalAmount,
        shippingCost: formattedOrders[0].shippingCost
      });
    }

    auditLog('PURCHASE_ORDERS_VIEWED', req.user.userId, {
      companyId,
      count: orders.length,
      filters: { search, supplierId, status, fromDate, toDate }
    });

    res.json({
      success: true,
      data: formattedOrders,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: parseInt(total),
        pages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    logger.error('Error fetching purchase orders', { 
      error: error.message, 
      userId: req.user.userId,
      companyId: req.user.companyId
    });
    res.status(500).json({
      success: false,
      error: 'Failed to fetch purchase orders'
    });
  }
});

// GET /api/purchase-orders/unbilled/list - Get unbilled purchase orders for multi-PO vendor billing
router.get('/unbilled/list', requirePermission('VIEW_PURCHASE'), async (req, res) => {
  try {
    const { companyId } = req.user;
    const db = getDbConnection(companyId);

    const { supplierId } = req.query;

    // Query to find POs that don't have a vendor bill
    // Company bills (bill_type='company') don't count as "billed" for multi-PO purposes
    // Only vendor bills (bill_type='vendor') mark a PO as billed
    let query = db('purchase_orders')
      .leftJoin('suppliers', 'purchase_orders.supplierId', 'suppliers.id')
      .leftJoin('purchase_invoices', function() {
        this.on('purchase_invoices.bill_type', '=', db.raw('?', ['vendor']))
            .andOn(db.raw('JSON_CONTAINS(purchase_invoices.covers_purchase_orders, CAST(purchase_orders.id AS JSON))'));
      })
      .select(
        'purchase_orders.id',
        'purchase_orders.orderNumber',
        'purchase_orders.orderDate',
        'purchase_orders.totalAmount',
        'purchase_orders.supplierId',
        'purchase_orders.status',
        'purchase_orders.source_type',
        'suppliers.name as supplierName'
      )
      .where('purchase_orders.status', 'received') // Only received POs can be billed
      .whereNull('purchase_invoices.id'); // Not already covered by vendor bill

    // Filter by supplier if provided
    if (supplierId) {
      query = query.where('purchase_orders.supplierId', supplierId);
    }

    const unbilledPOs = await query
      .orderBy('purchase_orders.orderDate', 'desc')
      .orderBy('purchase_orders.id', 'desc');

    // Convert DECIMAL strings to numbers
    const formattedPOs = unbilledPOs.map(po => ({
      ...po,
      totalAmount: parseFloat(po.totalAmount) || 0
    }));

    res.json({
      success: true,
      data: formattedPOs
    });

  } catch (error) {
    logger.error('Error fetching unbilled purchase orders', {
      error: error.message,
      userId: req.user.userId,
      companyId: req.user.companyId
    });
    res.status(500).json({
      success: false,
      error: 'Failed to fetch unbilled purchase orders'
    });
  }
});

// GET /api/purchase-orders/:id - Get specific purchase order with items
router.get('/:id', 
  validateParams(Joi.object({ id: Joi.number().integer().positive().required() })),
  requirePermission('VIEW_PURCHASE'),
  async (req, res) => {
    try {
      const { id } = req.params;
      const { companyId } = req.user;
      const db = getDbConnection(companyId);

      // Get order details with source tracking
      const order = await db('purchase_orders')
        .leftJoin('suppliers', 'purchase_orders.supplierId', 'suppliers.id')
        .leftJoin('collection_orders', 'purchase_orders.collection_order_id', 'collection_orders.id')
        .select(
          'purchase_orders.*',
          'suppliers.name as supplierName',
          'suppliers.specialization',
          'suppliers.phone as supplierPhone',
          'suppliers.address as supplierAddress',
          'suppliers.contactPerson',
          'collection_orders.orderNumber as collectionOrderNumber',
          'collection_orders.wcn_number',
          'collection_orders.wcn_date',
          'collection_orders.actualStartTime as collectionStartTime',
          'collection_orders.actualEndTime as collectionEndTime'
        )
        .where('purchase_orders.id', id)
        .first();

      if (!order) {
        return res.status(404).json({
          success: false,
          error: 'Purchase order not found'
        });
      }

      // Get order items
      logger.info(`ðŸ” Fetching items for PO ID: ${id}`);
      const items = await db('purchase_order_items')
        .leftJoin('materials', 'purchase_order_items.materialId', 'materials.id')
        .select(
          'purchase_order_items.*',
          'materials.name as materialName',
          'materials.code as materialCode',
          'materials.unit',
          'materials.category',
          'materials.standardPrice'
        )
        .where('purchase_order_items.purchaseOrderId', id)
        .orderBy('purchase_order_items.id');

      logger.info(`ðŸ“¦ Found ${items.length} items for PO #${id}`);
      logger.info(`ðŸ“‹ Items data:`, JSON.stringify(items, null, 2));

      auditLog('PURCHASE_ORDER_VIEWED', req.user.userId, {
        purchaseOrderId: id,
        orderNumber: order.orderNumber,
        supplierName: order.supplierName,
        itemsCount: items.length
      });

      // Parse attachments (handle both string and object from DB)
      let attachments = [];
      if (order.attachments) {
        if (typeof order.attachments === 'string') {
          try {
            attachments = JSON.parse(order.attachments);
          } catch (e) {
            logger.warn('Failed to parse attachments JSON string', { orderId: id, error: e.message });
            attachments = [];
          }
        } else if (Array.isArray(order.attachments)) {
          // Already parsed by Knex
          attachments = order.attachments;
        }
      }

      // Structure WCN details if PO is from WCN auto-generation
      let wcn_details = null;
      if (order.source_type === 'wcn_auto' && order.collection_order_id) {
        wcn_details = {
          wcn_number: order.wcn_number,
          wcn_date: order.wcn_date,
          collection_order_number: order.collectionOrderNumber,
          collection_start_time: order.collectionStartTime,
          collection_end_time: order.collectionEndTime
        };
      }

      // Convert DECIMAL strings to numbers for consistent JSON format
      const formattedOrder = {
        ...order,
        subtotal: parseFloat(order.subtotal) || 0,
        taxAmount: parseFloat(order.taxAmount) || 0,
        totalAmount: parseFloat(order.totalAmount) || 0,
        shippingCost: parseFloat(order.shippingCost) || 0,
        attachments: attachments,
        wcn_details: wcn_details,
        items: items.map(item => ({
          ...item,
          quantityOrdered: parseFloat(item.quantityOrdered) || 0,
          quantityReceived: parseFloat(item.quantityReceived) || 0,
          unitPrice: parseFloat(item.unitPrice) || 0,
          totalPrice: parseFloat(item.totalPrice) || 0,
          contractRate: item.contractRate ? parseFloat(item.contractRate) : null,
          contractSavings: parseFloat(item.contractSavings) || 0
        }))
      };

      logger.info(`âœ… Sending response with ${items.length} items`);
      logger.info('ðŸ’° PO financial values being sent:', {
        orderNumber: formattedOrder.orderNumber,
        subtotal: formattedOrder.subtotal,
        taxAmount: formattedOrder.taxAmount,
        totalAmount: formattedOrder.totalAmount,
        shippingCost: formattedOrder.shippingCost
      });

      res.json({
        success: true,
        data: formattedOrder
      });

    } catch (error) {
      logger.error('Error fetching purchase order', { 
        error: error.message, 
        purchaseOrderId: req.params.id,
        userId: req.user.userId
      });
      res.status(500).json({
        success: false,
        error: 'Failed to fetch purchase order'
      });
    }
  }
);

// POST /api/purchase-orders - Create new purchase order
router.post('/', 
  validate(purchaseOrderSchema),
  requirePermission('CREATE_PURCHASE'),
  async (req, res) => {
    try {
      const { companyId, userId } = req.user;
      const db = getDbConnection(companyId);

      // Extract items array and remove from order data
      const { items, supplierName, ...orderFields } = req.body;

      // Validate supplier exists
      const supplier = await db('suppliers')
        .where({ id: orderFields.supplierId })
        .first();

      if (!supplier) {
        return res.status(400).json({
          success: false,
          error: 'Supplier not found or inactive'
        });
      }

      // Generate order number if not provided
      const orderNumber = orderFields.orderNumber || `PO-${Date.now()}-${Math.floor(Math.random() * 1000)}`;

      logger.info('ðŸ’° Received financial values for PO create:', {
        subtotal: orderFields.subtotal,
        taxAmount: orderFields.taxAmount,
        totalAmount: orderFields.totalAmount,
        shippingCost: orderFields.shippingCost,
        itemsCount: items?.length || 0
      });

      // Prepare order data to match database schema
      const orderData = {
        orderNumber,
        supplierId: orderFields.supplierId,
        supplierName: supplier.name,
        supplierPhone: supplier.phone || null,
        supplierEmail: supplier.email || null,
        supplierAddress: supplier.address || null,
        orderDate: orderFields.orderDate || new Date(),
        expectedDeliveryDate: orderFields.expectedDeliveryDate || null,
        actualDeliveryDate: null,
        status: orderFields.status || 'draft',
        subtotal: parseFloat(orderFields.subtotal) || 0,
        taxAmount: parseFloat(orderFields.taxAmount) || 0,
        shippingCost: parseFloat(orderFields.shippingCost) || 0,
        totalAmount: parseFloat(orderFields.totalAmount) || 0,
        currency: 'OMR',
        deliveryAddress: orderFields.deliveryAddress || null,
        terms: orderFields.paymentTerms ? formatPaymentTermsForDisplay(orderFields.paymentTerms) : 'Payment Terms: Net 30 Days',
        notes: orderFields.notes || null,
        createdBy: userId,
        approvedBy: null,
        approvedAt: null,
        created_at: new Date(),
        updated_at: new Date()
      };

      logger.info('ðŸ“ Saving orderData:', {
        subtotal: orderData.subtotal,
        taxAmount: orderData.taxAmount,
        totalAmount: orderData.totalAmount,
        shippingCost: orderData.shippingCost
      });

      // Use transaction to ensure both order and items are created
      const result = await db.transaction(async (trx) => {
        // Insert purchase order
        const [orderId] = await trx('purchase_orders').insert(orderData);
        
        // Insert purchase order items if provided
        if (items && items.length > 0) {
          const itemsData = items.map(item => ({
            purchaseOrderId: orderId,
            materialId: parseInt(item.materialId),
            quantityOrdered: parseFloat(item.quantity),
            quantityReceived: 0, // Initially 0
            unitPrice: parseFloat(item.rate),
            contractRate: null, // To be populated later with contract rates
            appliedRateType: null,
            contractSavings: 0,
            totalPrice: parseFloat(item.amount),
            batchNumber: null,
            expiryDate: null,
            notes: null,
            created_at: new Date(),
            updated_at: new Date()
          }));
          
          await trx('purchase_order_items').insert(itemsData);
        }
        
        return orderId;
      });
      
      // Fetch complete order with supplier info
      const newOrder = await db('purchase_orders')
        .leftJoin('suppliers', 'purchase_orders.supplierId', 'suppliers.id')
        .select(
          'purchase_orders.*',
          'suppliers.name as supplierName'
        )
        .where('purchase_orders.id', result)
        .first();

      auditLog('PURCHASE_ORDER_CREATED', userId, {
        purchaseOrderId: result,
        orderNumber: newOrder.orderNumber,
        supplierName: newOrder.supplierName,
        totalAmount: newOrder.totalAmount,
        itemCount: items?.length || 0
      });

      logger.info('Purchase order created', {
        purchaseOrderId: result,
        orderNumber: newOrder.orderNumber,
        createdBy: userId,
        itemCount: items?.length || 0
      });

      res.status(201).json({
        success: true,
        message: 'Purchase order created successfully',
        data: newOrder
      });

    } catch (error) {
      logger.error('Error creating purchase order', { 
        error: error.message, 
        userId: req.user.userId,
        orderData: req.body
      });
      res.status(500).json({
        success: false,
        error: 'Failed to create purchase order'
      });
    }
  }
);

// PUT /api/purchase-orders/:id - Update purchase order
router.put('/:id',
  validateParams(Joi.object({ id: Joi.number().integer().positive().required() })),
  validate(purchaseOrderSchema),
  requirePermission('EDIT_PURCHASE'),
  async (req, res) => {
    try {
      const { id } = req.params;
      const { companyId, userId } = req.user;
      const db = getDbConnection(companyId);

      // Check if order exists
      const existingOrder = await db('purchase_orders')
        .where({ id })
        .first();

      if (!existingOrder) {
        return res.status(404).json({
          success: false,
          error: 'Purchase order not found'
        });
      }

      // Extract only the fields that should be updated in the database
      const {
        orderNumber,
        supplierId,
        orderDate,
        expectedDeliveryDate,
        status,
        subtotal,
        taxAmount,
        totalAmount,
        shippingCost,
        notes,
        items // Extract items for separate handling
      } = req.body;

      logger.info('ðŸ’° Received financial values for PO update:', {
        subtotal,
        taxAmount,
        totalAmount,
        shippingCost,
        itemsCount: items?.length || 0
      });

      // Update order with only valid database fields
      const updateData = {
        orderNumber,
        supplierId,
        orderDate,
        expectedDeliveryDate: expectedDeliveryDate || null,
        status,
        subtotal: parseFloat(subtotal) || 0,
        taxAmount: parseFloat(taxAmount) || 0,
        totalAmount: parseFloat(totalAmount) || 0,
        shippingCost: parseFloat(shippingCost) || 0,
        notes: notes || null,
        updated_at: new Date()
      };

      logger.info('ðŸ“ Saving updateData:', updateData);

      await db('purchase_orders')
        .where({ id })
        .update(updateData);

      // If items provided, update them
      if (items && items.length > 0) {
        // Delete existing items
        await db('purchase_order_items').where({ purchaseOrderId: id }).delete();

        // Insert new items
        const itemsData = items.map(item => ({
          purchaseOrderId: id,
          materialId: parseInt(item.materialId),
          quantityOrdered: parseFloat(item.quantity) || 0,
          quantityReceived: 0,
          unitPrice: parseFloat(item.rate) || 0,
          contractRate: null,
          appliedRateType: null,
          contractSavings: 0,
          totalPrice: parseFloat(item.amount) || (parseFloat(item.quantity) * parseFloat(item.rate)) || 0,
          batchNumber: null,
          expiryDate: null,
          notes: null,
          created_at: new Date(),
          updated_at: new Date()
        }));

        await db('purchase_order_items').insert(itemsData);
      }

      const updatedOrder = await db('purchase_orders')
        .leftJoin('suppliers', 'purchase_orders.supplierId', 'suppliers.id')
        .select(
          'purchase_orders.*',
          'suppliers.name as supplierName'
        )
        .where('purchase_orders.id', id)
        .first();

      auditLog('PURCHASE_ORDER_UPDATED', userId, {
        purchaseOrderId: id,
        orderNumber: updatedOrder.orderNumber
      });

      logger.info('Purchase order updated', {
        purchaseOrderId: id,
        orderNumber: updatedOrder.orderNumber,
        updatedBy: userId
      });

      res.json({
        success: true,
        message: 'Purchase order updated successfully',
        data: updatedOrder
      });

    } catch (error) {
      logger.error('Error updating purchase order', {
        error: error.message,
        purchaseOrderId: req.params.id,
        userId: req.user.userId
      });
      res.status(500).json({
        success: false,
        error: 'Failed to update purchase order'
      });
    }
  }
);

// POST /api/purchase-orders/:id/items - Add item to purchase order
router.post('/:id/items',
  validateParams(Joi.object({ id: Joi.number().integer().positive().required() })),
  validate(purchaseOrderItemSchema.fork('purchaseOrderId', schema => schema.optional())),
  requirePermission('CREATE_PURCHASE'),
  async (req, res) => {
    try {
      const { id } = req.params;
      const { companyId } = req.user;
      const db = getDbConnection(companyId);

      // Verify order exists and is editable
      const order = await db('purchase_orders')
        .leftJoin('suppliers', 'purchase_orders.supplierId', 'suppliers.id')
        .select(
          'purchase_orders.*',
          'suppliers.name as supplierName'
        )
        .where({ 'purchase_orders.id': id })
        .whereIn('purchase_orders.status', ['draft', 'pending'])
        .first();

      if (!order) {
        return res.status(404).json({
          success: false,
          error: 'Purchase order not found or not editable'
        });
      }

      // Verify material exists
      const material = await db('materials')
        .where({ id: req.body.materialId })
        .first();

      if (!material) {
        return res.status(400).json({
          success: false,
          error: 'Material not found or inactive'
        });
      }

      // Check for active supplier contract rates
      let contractRate = null;
      let appliedRateType = null;
      let contractSavings = 0;
      let effectiveUnitPrice = req.body.unitPrice;

      const supplierContractRate = await db('contract_rates')
        .leftJoin('contracts', 'contract_rates.contractId', 'contracts.id')
        .select(
          'contract_rates.*',
          'contracts.contractNumber',
          'contracts.endDate as contractEndDate'
        )
        .where('contracts.supplierId', order.supplierId)
        .where('contract_rates.materialId', req.body.materialId)
        .where('contracts.status', 'active')
        .where('contracts.startDate', '<=', new Date())
        .where('contracts.endDate', '>=', new Date())
        .where('contract_rates.isActive', true)
        .first();

      if (supplierContractRate) {
        // Apply contract rate based on type
        switch (supplierContractRate.rateType) {
          case 'fixed_rate':
            contractRate = supplierContractRate.contractRate;
            effectiveUnitPrice = supplierContractRate.contractRate;
            appliedRateType = 'fixed_rate';
            contractSavings = (req.body.unitPrice - supplierContractRate.contractRate) * req.body.quantity;
            break;
          
          case 'discount_percentage':
            contractRate = req.body.unitPrice * (1 - supplierContractRate.discountPercentage / 100);
            effectiveUnitPrice = contractRate;
            appliedRateType = 'discount_percentage';
            contractSavings = (req.body.unitPrice - contractRate) * req.body.quantity;
            break;
          
          case 'minimum_price_guarantee':
            contractRate = Math.min(req.body.unitPrice, supplierContractRate.contractRate);
            effectiveUnitPrice = contractRate;
            appliedRateType = 'minimum_price_guarantee';
            contractSavings = (req.body.unitPrice - contractRate) * req.body.quantity;
            break;
        }

        logger.info('Applied supplier contract rate', {
          purchaseOrderId: id,
          supplierId: order.supplierId,
          materialId: req.body.materialId,
          rateType: supplierContractRate.rateType,
          originalPrice: req.body.unitPrice,
          contractPrice: contractRate,
          savings: contractSavings
        });
      }

      const itemData = {
        ...req.body,
        purchaseOrderId: id,
        unitPrice: effectiveUnitPrice,
        totalPrice: effectiveUnitPrice * req.body.quantity,
        contractRate: contractRate,
        appliedRateType: appliedRateType,
        contractSavings: Math.max(0, contractSavings), // Ensure non-negative savings
        created_at: new Date(),
        updated_at: new Date()
      };

      const [itemId] = await db('purchase_order_items').insert(itemData);
      
      // Update order totals
      const orderItems = await db('purchase_order_items')
        .where({ purchaseOrderId: id })
        .select(db.raw('SUM(totalPrice) as subtotal'));

      const subtotal = orderItems[0].subtotal || 0;
      const taxAmount = subtotal * 0.05; // 5% tax
      const totalAmount = subtotal + taxAmount + (order.shippingCost || 0) - (order.discountAmount || 0);

      await db('purchase_orders')
        .where({ id })
        .update({
          subtotal,
          taxAmount,
          totalAmount,
          updated_at: new Date()
        });

      const newItem = await db('purchase_order_items')
        .leftJoin('materials', 'purchase_order_items.materialId', 'materials.id')
        .select(
          'purchase_order_items.*',
          'materials.name as materialName',
          'materials.code as materialCode'
        )
        .where('purchase_order_items.id', itemId)
        .first();

      auditLog('PURCHASE_ORDER_ITEM_ADDED', req.user.userId, {
        purchaseOrderId: id,
        itemId,
        materialName: newItem.materialName,
        quantity: newItem.quantity,
        totalPrice: newItem.totalPrice,
        contractApplied: !!contractRate,
        appliedRateType: appliedRateType,
        contractSavings: contractSavings
      });

      res.status(201).json({
        success: true,
        message: 'Item added to purchase order successfully',
        data: newItem
      });

    } catch (error) {
      logger.error('Error adding purchase order item', { 
        error: error.message, 
        purchaseOrderId: req.params.id,
        userId: req.user.userId,
        itemData: req.body
      });
      res.status(500).json({
        success: false,
        error: 'Failed to add purchase order item'
      });
    }
  }
);

// PUT /api/purchase-orders/:id/receive - Receive purchase order (update inventory)
router.put('/:id/receive',
  validateParams(Joi.object({ id: Joi.number().integer().positive().required() })),
  validate(Joi.object({
    receivedItems: Joi.array().items(
      Joi.object({
        itemId: Joi.number().integer().positive().required(),
        receivedQuantity: Joi.number().min(0).precision(3).required(),
        contentQuantity: Joi.number().min(0).precision(3).optional(), // For composite materials
        batchNumber: Joi.string().max(100).allow('').optional(),
        expiryDate: Joi.date().optional(),
        condition: Joi.string().valid('new', 'used', 'refurbished', 'damaged').default('new'),
        location: Joi.string().max(100).allow('').optional()
      })
    ).required(),
    notes: Joi.string().allow('').optional()
  })),
  requirePermission('EDIT_PURCHASE'),
  async (req, res) => {
    try {
      const { id } = req.params;
      const { receivedItems, notes } = req.body;
      const { companyId } = req.user;
      const db = getDbConnection(companyId);

      const order = await db('purchase_orders')
        .where({ id, status: 'approved' })
        .first();

      if (!order) {
        return res.status(404).json({
          success: false,
          error: 'Purchase order not found or not ready for receiving'
        });
      }

      // Check if this is a WCN auto-generated PO
      if (order.source_type === 'wcn_auto') {
        // WCN-generated POs already have inventory updated during WCN finalization
        // Just update status to received
        await db('purchase_orders')
          .where({ id })
          .update({
            status: 'received',
            notes: notes ? `${order.notes || ''}\nReceived (WCN auto): ${notes}` : order.notes,
            updated_at: new Date()
          });

        auditLog('PURCHASE_ORDER_RECEIVED_WCN_AUTO', req.user.userId, {
          purchaseOrderId: id,
          orderNumber: order.orderNumber,
          message: 'WCN auto-generated PO - inventory already updated during WCN finalization'
        });

        return res.json({
          success: true,
          message: 'Purchase order marked as received (inventory already updated via WCN finalization)',
          wcn_auto: true
        });
      }

      // Manual PO - process inventory updates
      await db.transaction(async (trx) => {
        for (const receivedItem of receivedItems) {
          // Get the order item details
          const orderItem = await trx('purchase_order_items')
            .where({ id: receivedItem.itemId, purchaseOrderId: id })
            .first();

          if (!orderItem) continue;

          // Check if this material is composite
          const compositions = await trx('material_compositions')
            .leftJoin('materials', 'material_compositions.component_material_id', 'materials.id')
            .select(
              'material_compositions.*',
              'materials.name as component_material_name',
              'materials.code as component_material_code'
            )
            .where('material_compositions.composite_material_id', orderItem.materialId)
            .where('material_compositions.is_active', 1);

          const isComposite = compositions.length > 0;

          if (isComposite) {
            // This is a composite material - split into components
            const breakdown = {
              composite_material_id: orderItem.materialId,
              composite_quantity: receivedItem.receivedQuantity,
              content_quantity: receivedItem.contentQuantity || null,
              split_date: new Date(),
              components: []
            };

            for (const composition of compositions) {
              // Calculate component quantity based on type
              let componentQuantity;
              if (composition.component_type === 'container') {
                // Containers = number of composite units (drums, boxes, etc.)
                componentQuantity = receivedItem.receivedQuantity;
              } else if (composition.component_type === 'content') {
                // Content = actual quantity provided (or use composite quantity as fallback)
                componentQuantity = receivedItem.contentQuantity || receivedItem.receivedQuantity;
              }

              // Add component to inventory
              await trx('inventory').insert({
                materialId: composition.component_material_id,
                batchNumber: receivedItem.batchNumber || `PO-${order.orderNumber}-${Date.now()}`,
                quantity: componentQuantity,
                reservedQuantity: 0,
                averageCost: 0, // Components don't have individual cost
                lastPurchasePrice: 0,
                lastPurchaseDate: new Date(),
                expiryDate: receivedItem.expiryDate,
                location: receivedItem.location || 'Main Warehouse',
                condition: receivedItem.condition,
                notes: `Split from composite material (PO ${order.orderNumber})`,
                minimumStockLevel: 0,
                maximumStockLevel: 0,
                isActive: true,
                created_at: new Date(),
                updated_at: new Date()
              });

              // Create transaction record for component
              await trx('transactions').insert({
                transactionNumber: `SPLIT-${Date.now()}-${orderItem.id}-${composition.id}`,
                transactionType: 'purchase',
                referenceId: id,
                referenceType: 'purchase_order',
                materialId: composition.component_material_id,
                quantity: componentQuantity,
                amount: 0, // No separate cost for components
                transactionDate: new Date(),
                description: `Component from ${composition.component_type} - PO ${order.orderNumber}`,
                createdBy: req.user.userId,
                created_at: new Date(),
                updated_at: new Date()
              });

              // Create FIFO batch for component tracking
              // Cost allocation: content component gets the full cost, containers get 0
              const componentBatchNum = `${receivedItem.batchNumber || `PO-${order.orderNumber}`}-${composition.component_type}-${Date.now()}`;
              const componentUnitCost = composition.component_type === 'content'
                ? orderItem.unitPrice  // Content gets the full unit cost
                : 0;  // Containers have no COGS attribution

              await createBatch(trx, {
                materialId: composition.component_material_id,
                batchNumber: componentBatchNum,
                supplierId: order.supplierId,
                purchaseOrderId: id,
                branchId: order.branchId || null,
                purchaseDate: new Date().toISOString().split('T')[0],
                quantityReceived: componentQuantity,
                unitCost: componentUnitCost,
                expiryDate: receivedItem.expiryDate || null,
                location: receivedItem.location || 'Main Warehouse',
                condition: receivedItem.condition || 'new',
                notes: `Component (${composition.component_type}) split from composite - PO ${order.orderNumber}`,
                userId: req.user.userId
              });

              breakdown.components.push({
                material_id: composition.component_material_id,
                material_name: composition.component_material_name,
                material_code: composition.component_material_code,
                component_type: composition.component_type,
                capacity: composition.capacity,
                capacity_unit: composition.capacity_unit,
                total_quantity: componentQuantity
              });
            }

            // Mark order item as composite and store breakdown
            await trx('purchase_order_items')
              .where({ id: receivedItem.itemId })
              .update({
                is_composite_material: 1,
                composite_breakdown: JSON.stringify(breakdown),
                updated_at: new Date()
              });

            logger.info('Composite material split', {
              orderId: id,
              orderNumber: order.orderNumber,
              compositeMaterialId: orderItem.materialId,
              compositeQuantity: receivedItem.receivedQuantity,
              componentsCount: compositions.length,
              breakdown
            });

          } else {
            // Regular material - add to inventory as-is
            const batchNum = receivedItem.batchNumber || `PO-${order.orderNumber}-${Date.now()}`;

            await trx('inventory').insert({
              materialId: orderItem.materialId,
              batchNumber: batchNum,
              quantity: receivedItem.receivedQuantity,
              reservedQuantity: 0,
              averageCost: orderItem.unitPrice,
              lastPurchasePrice: orderItem.unitPrice,
              lastPurchaseDate: new Date(),
              expiryDate: receivedItem.expiryDate,
              location: receivedItem.location || 'Main Warehouse',
              condition: receivedItem.condition,
              notes: `Received from PO ${order.orderNumber}`,
              minimumStockLevel: 0,
              maximumStockLevel: 0,
              isActive: true,
              created_at: new Date(),
              updated_at: new Date()
            });

            // Create FIFO batch for tracking
            await createBatch(trx, {
              materialId: orderItem.materialId,
              batchNumber: batchNum,
              supplierId: order.supplierId,
              purchaseOrderId: id,
              branchId: order.branchId || null,
              purchaseDate: new Date().toISOString().split('T')[0],
              quantityReceived: receivedItem.receivedQuantity,
              unitCost: orderItem.unitPrice,
              expiryDate: receivedItem.expiryDate || null,
              location: receivedItem.location || 'Main Warehouse',
              condition: receivedItem.condition || 'new',
              notes: `Received from PO ${order.orderNumber}`,
              userId: req.user.userId
            });

            // Create transaction record
            await trx('transactions').insert({
              transactionNumber: `PURCHASE-${Date.now()}-${orderItem.id}`,
              transactionType: 'purchase',
              referenceId: id,
              referenceType: 'purchase_order',
              materialId: orderItem.materialId,
              quantity: receivedItem.receivedQuantity,
              amount: receivedItem.receivedQuantity * orderItem.unitPrice,
              transactionDate: new Date(),
              description: `Purchase received - Order ${order.orderNumber}`,
              createdBy: req.user.userId,
              created_at: new Date(),
              updated_at: new Date()
            });

            logger.info('FIFO batch created from PO receiving', {
              purchaseOrderId: id,
              materialId: orderItem.materialId,
              batchNumber: batchNum,
              quantity: receivedItem.receivedQuantity,
              unitCost: orderItem.unitPrice
            });
          }
        }

        // Update purchase order status
        await trx('purchase_orders')
          .where({ id })
          .update({
            status: 'received',
            notes: notes ? `${order.notes || ''}\nReceived: ${notes}` : order.notes,
            updated_at: new Date()
          });
      });

      auditLog('PURCHASE_ORDER_RECEIVED', req.user.userId, {
        purchaseOrderId: id,
        orderNumber: order.orderNumber,
        itemsReceived: receivedItems.length
      });

      res.json({
        success: true,
        message: 'Purchase order received successfully and inventory updated'
      });

    } catch (error) {
      logger.error('Error receiving purchase order', { 
        error: error.message, 
        purchaseOrderId: req.params.id,
        userId: req.user.userId
      });
      res.status(500).json({
        success: false,
        error: 'Failed to receive purchase order'
      });
    }
  }
);

// POST /api/purchase-orders/:id/approve - Approve a purchase order
router.post('/:id/approve',
  validateParams(Joi.object({
    id: Joi.number().integer().positive().required()
  })),
  validate(Joi.object({
    approvalNotes: Joi.string().allow('').optional(),
    approvedAmount: Joi.number().min(0).precision(3).optional()
  })),
  requirePermission('APPROVE_PURCHASE'),
  async (req, res) => {
    try {
      const { id } = req.params;
      const { approvalNotes, approvedAmount } = req.body;
      const { companyId, userId } = req.user;
      const db = getDbConnection(companyId);

      const order = await db('purchase_orders')
        .where({ id, status: 'draft' })
        .first();

      if (!order) {
        return res.status(404).json({
          success: false,
          error: 'Purchase order not found or not ready for approval'
        });
      }

      await db('purchase_orders')
        .where({ id })
        .update({
          status: 'approved',
          approvedBy: userId,
          approvedAt: new Date(),
          notes: approvalNotes ? `${order.notes || ''}\nApproval: ${approvalNotes}` : order.notes,
          updated_at: new Date()
        });

      auditLog('PURCHASE_ORDER_APPROVED', userId, {
        purchaseOrderId: id,
        orderNumber: order.orderNumber,
        originalAmount: order.totalAmount,
        approvedAmount: approvedAmount || order.totalAmount,
        approvalNotes
      });

      res.json({
        success: true,
        message: 'Purchase order approved successfully'
      });

    } catch (error) {
      logger.error('Error approving purchase order', { 
        error: error.message, 
        purchaseOrderId: req.params.id,
        userId: req.user.userId
      });
      res.status(500).json({
        success: false,
        error: 'Failed to approve purchase order'
      });
    }
  }
);

// PATCH /api/purchase-orders/:id/status - Update purchase order status
router.patch('/:id/status',
  validateParams(Joi.object({
    id: Joi.number().integer().positive().required()
  })),
  validate(Joi.object({
    status: Joi.string().valid('draft', 'pending', 'approved', 'sent', 'received', 'completed', 'cancelled').required(),
    notes: Joi.string().allow('').optional()
  })),
  requirePermission('EDIT_PURCHASE'),
  async (req, res) => {
    try {
      const { id } = req.params;
      const { status, notes } = req.body;
      const { companyId, userId } = req.user;
      const db = getDbConnection(companyId);

      const order = await db('purchase_orders')
        .where({ id })
        .first();

      if (!order) {
        return res.status(404).json({
          success: false,
          error: 'Purchase order not found'
        });
      }

      // Validate status transitions
      const validTransitions = {
        'draft': ['pending', 'approved', 'cancelled'],
        'pending': ['approved', 'cancelled'],
        'approved': ['sent', 'cancelled'],
        'sent': ['received', 'cancelled'],
        'received': ['completed'],
        'completed': [], // Final state
        'cancelled': [] // Final state
      };

      if (!validTransitions[order.status]?.includes(status)) {
        return res.status(400).json({
          success: false,
          error: `Cannot change status from ${order.status} to ${status}`
        });
      }

      const updateData = {
        status: status,
        updated_at: new Date()
      };

      if (notes) {
        updateData.notes = order.notes ? `${order.notes}\nStatus Update: ${notes}` : notes;
      }

      // Add status-specific fields
      if (status === 'sent') {
        updateData.sentAt = new Date();
        updateData.sentBy = userId;
      } else if (status === 'cancelled') {
        updateData.cancelledAt = new Date();
        updateData.cancelledBy = userId;
      }

      await db('purchase_orders')
        .where({ id })
        .update(updateData);

      auditLog('PURCHASE_ORDER_STATUS_CHANGED', userId, {
        purchaseOrderId: id,
        orderNumber: order.orderNumber,
        fromStatus: order.status,
        toStatus: status,
        notes
      });

      res.json({
        success: true,
        message: `Purchase order status updated to ${status} successfully`
      });

    } catch (error) {
      logger.error('Error updating purchase order status', { 
        error: error.message, 
        purchaseOrderId: req.params.id,
        userId: req.user.userId
      });
      res.status(500).json({
        success: false,
        error: 'Failed to update purchase order status'
      });
    }
  }
);

// GET /api/purchase-orders/pending - Get pending purchase orders for approval
router.get('/pending', 
  requirePermission('VIEW_PURCHASE'),
  async (req, res) => {
    try {
      const { companyId } = req.user;
      const db = getDbConnection(companyId);
      
      const pendingOrders = await db('purchase_orders')
        .leftJoin('suppliers', 'purchase_orders.supplierId', 'suppliers.id')
        .select(
          'purchase_orders.*',
          'suppliers.name as supplierName',
          'suppliers.contactPerson as supplierContact'
        )
        .where('purchase_orders.status', 'draft')
        .orderBy('purchase_orders.created_at', 'desc');

      res.json({
        success: true,
        data: pendingOrders,
        message: 'Pending purchase orders retrieved successfully'
      });

    } catch (error) {
      logger.error('Error fetching pending purchase orders', { 
        error: error.message, 
        userId: req.user.userId,
        companyId: req.user.companyId
      });
      res.status(500).json({
        success: false,
        error: 'Failed to fetch pending purchase orders'
      });
    }
  }
);

// GET /api/purchase-orders/contract-rate/:supplierId/:materialId - Get contract rate for supplier and material
router.get('/contract-rate/:supplierId/:materialId',
  validateParams(Joi.object({ 
    supplierId: Joi.number().integer().positive().required(),
    materialId: Joi.number().integer().positive().required()
  })),
  requirePermission('VIEW_PURCHASE'),
  async (req, res) => {
    try {
      const { supplierId, materialId } = req.params;
      const { companyId } = req.user;
      const db = getDbConnection(companyId);

      // Get material standard price
      const material = await db('materials')
        .select('standardPrice', 'name', 'code', 'unit')
        .where('id', materialId)
        .first();

      if (!material) {
        return res.status(404).json({
          success: false,
          error: 'Material not found'
        });
      }

      // Get active contract rate for this material and supplier
      const contractRate = await db('contract_rates')
        .leftJoin('contracts', 'contract_rates.contractId', 'contracts.id')
        .select(
          'contract_rates.*',
          'contracts.contractNumber',
          'contracts.endDate as contractEndDate'
        )
        .where('contracts.supplierId', supplierId)
        .where('contract_rates.materialId', materialId)
        .where('contracts.status', 'active')
        .where('contracts.startDate', '<=', new Date())
        .where('contracts.endDate', '>=', new Date())
        .where('contract_rates.isActive', true)
        .first();

      if (!contractRate) {
        return res.json({
          success: true,
          data: {
            hasContractRate: false,
            standardPrice: material.standardPrice,
            effectivePrice: material.standardPrice,
            material
          }
        });
      }

      // Calculate effective price based on contract type
      let effectivePrice = material.standardPrice;
      let savings = 0;
      let savingsPercentage = 0;

      switch (contractRate.rateType) {
        case 'fixed_rate':
          effectivePrice = contractRate.contractRate;
          savings = material.standardPrice - contractRate.contractRate;
          savingsPercentage = material.standardPrice > 0 ? (savings / material.standardPrice) * 100 : 0;
          break;
        
        case 'discount_percentage':
          effectivePrice = material.standardPrice * (1 - contractRate.discountPercentage / 100);
          savings = material.standardPrice - effectivePrice;
          savingsPercentage = contractRate.discountPercentage;
          break;
        
        case 'minimum_price_guarantee':
          effectivePrice = Math.min(material.standardPrice, contractRate.contractRate);
          savings = material.standardPrice - effectivePrice;
          savingsPercentage = material.standardPrice > 0 ? (savings / material.standardPrice) * 100 : 0;
          break;
      }

      res.json({
        success: true,
        data: {
          hasContractRate: true,
          standardPrice: material.standardPrice,
          effectivePrice: parseFloat(effectivePrice.toFixed(3)),
          savings: parseFloat(savings.toFixed(3)),
          savingsPercentage: parseFloat(savingsPercentage.toFixed(2)),
          contractRate,
          material,
          isExpiringSoon: new Date(contractRate.contractEndDate) < new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
        }
      });

    } catch (error) {
      logger.error('Error fetching purchase contract rate', { 
        error: error.message, 
        supplierId: req.params.supplierId,
        materialId: req.params.materialId,
        userId: req.user.userId
      });
      res.status(500).json({
        success: false,
        error: 'Failed to fetch purchase contract rate'
      });
    }
  }
);

// POST /api/purchase-orders/:id/attachments - Upload attachments to purchase order
router.post('/:id/attachments',
  validateParams(Joi.object({ id: Joi.number().integer().positive().required() })),
  requirePermission('CREATE_PURCHASE'),
  (req, res, next) => {
    // Set upload type for multer destination
    req.params.type = 'purchase-orders';
    next();
  },
  uploadMultiple,
  async (req, res) => {
    try {
      const { id } = req.params;
      const { companyId, userId } = req.user;
      const db = getDbConnection(companyId);

      // Check if purchase order exists
      const order = await db('purchase_orders')
        .where({ id })
        .first();

      if (!order) {
        // Delete uploaded files if order doesn't exist
        if (req.files && req.files.length > 0) {
          req.files.forEach(file => {
            deleteFile(`purchase-orders/${file.filename}`);
          });
        }
        return res.status(404).json({
          success: false,
          error: 'Purchase order not found'
        });
      }

      // Get existing attachments
      let attachments = [];
      if (order.attachments) {
        try {
          attachments = JSON.parse(order.attachments);
        } catch (e) {
          attachments = [];
        }
      }

      // Add new attachments
      if (req.files && req.files.length > 0) {
        req.files.forEach(file => {
          attachments.push({
            filename: file.filename,
            originalName: file.originalname,
            mimetype: file.mimetype,
            size: file.size,
            path: `purchase-orders/${file.filename}`,
            uploadedAt: new Date().toISOString(),
            uploadedBy: userId
          });
        });
      }

      // Update purchase order with new attachments
      await db('purchase_orders')
        .where({ id })
        .update({
          attachments: JSON.stringify(attachments),
          updated_at: new Date()
        });

      auditLog('PURCHASE_ORDER_ATTACHMENTS_UPLOADED', userId, {
        purchaseOrderId: id,
        orderNumber: order.orderNumber,
        filesCount: req.files.length
      });

      res.json({
        success: true,
        data: attachments,
        message: `${req.files.length} file(s) uploaded successfully`
      });

    } catch (error) {
      logger.error('Error uploading purchase order attachments', {
        error: error.message,
        purchaseOrderId: req.params.id,
        userId: req.user.userId
      });
      res.status(500).json({
        success: false,
        error: 'Failed to upload attachments'
      });
    }
  }
);

// GET /api/purchase-orders/:id/attachments - Get attachments for purchase order
router.get('/:id/attachments',
  validateParams(Joi.object({ id: Joi.number().integer().positive().required() })),
  requirePermission('VIEW_PURCHASE'),
  async (req, res) => {
    try {
      const { id } = req.params;
      const { companyId } = req.user;
      const db = getDbConnection(companyId);

      const order = await db('purchase_orders')
        .select('attachments')
        .where({ id })
        .first();

      if (!order) {
        return res.status(404).json({
          success: false,
          error: 'Purchase order not found'
        });
      }

      let attachments = [];
      if (order.attachments) {
        try {
          attachments = JSON.parse(order.attachments);
        } catch (e) {
          attachments = [];
        }
      }

      res.json({
        success: true,
        data: attachments
      });

    } catch (error) {
      logger.error('Error fetching purchase order attachments', {
        error: error.message,
        purchaseOrderId: req.params.id,
        userId: req.user.userId
      });
      res.status(500).json({
        success: false,
        error: 'Failed to fetch attachments'
      });
    }
  }
);

// DELETE /api/purchase-orders/:id/attachments/:filename - Delete attachment from purchase order
router.delete('/:id/attachments/:filename',
  validateParams(Joi.object({
    id: Joi.number().integer().positive().required(),
    filename: Joi.string().required()
  })),
  requirePermission('CREATE_PURCHASE'),
  async (req, res) => {
    try {
      const { id, filename } = req.params;
      const { companyId, userId } = req.user;
      const db = getDbConnection(companyId);

      const order = await db('purchase_orders')
        .where({ id })
        .first();

      if (!order) {
        return res.status(404).json({
          success: false,
          error: 'Purchase order not found'
        });
      }

      let attachments = [];
      if (order.attachments) {
        try {
          attachments = JSON.parse(order.attachments);
        } catch (e) {
          attachments = [];
        }
      }

      // Find and remove the attachment
      const attachmentIndex = attachments.findIndex(att => att.filename === filename);

      if (attachmentIndex === -1) {
        return res.status(404).json({
          success: false,
          error: 'Attachment not found'
        });
      }

      const removedAttachment = attachments[attachmentIndex];
      attachments.splice(attachmentIndex, 1);

      // Delete the file from disk
      deleteFile(`purchase-orders/${filename}`);

      // Update database
      await db('purchase_orders')
        .where({ id })
        .update({
          attachments: JSON.stringify(attachments),
          updated_at: new Date()
        });

      auditLog('PURCHASE_ORDER_ATTACHMENT_DELETED', userId, {
        purchaseOrderId: id,
        orderNumber: order.orderNumber,
        filename: removedAttachment.originalName
      });

      res.json({
        success: true,
        message: 'Attachment deleted successfully'
      });

    } catch (error) {
      logger.error('Error deleting purchase order attachment', {
        error: error.message,
        purchaseOrderId: req.params.id,
        filename: req.params.filename,
        userId: req.user.userId
      });
      res.status(500).json({
        success: false,
        error: 'Failed to delete attachment'
      });
    }
  }
);

// POST /api/purchase-orders/:id/link-wcn - Manually link PO to WCN and update inventory
router.post('/:id/link-wcn',
  validateParams(Joi.object({ id: Joi.number().integer().positive().required() })),
  validate(Joi.object({
    collectionOrderId: Joi.number().integer().positive().required(),
    notes: Joi.string().allow('').optional()
  })),
  requirePermission('EDIT_PURCHASE'),
  async (req, res) => {
    try {
      const { id } = req.params;
      const { collectionOrderId, notes } = req.body;
      const { companyId, userId } = req.user;
      const db = getDbConnection(companyId);

      await db.transaction(async (trx) => {
        // 1. Verify PO exists and is manual
        const po = await trx('purchase_orders')
          .where({ id })
          .first();

        if (!po) {
          throw new Error('Purchase order not found');
        }

        if (po.source_type === 'wcn_auto') {
          throw new Error('Cannot manually link WCN to auto-generated PO. This PO was already created from WCN finalization.');
        }

        if (po.collection_order_id) {
          throw new Error('This PO is already linked to a collection order');
        }

        // 2. Verify collection order exists and is finalized
        const collection = await trx('collection_orders')
          .where({ id: collectionOrderId })
          .first();

        if (!collection) {
          throw new Error('Collection order not found');
        }

        if (!collection.is_finalized || !collection.wcn_number) {
          throw new Error('Collection order must be finalized with WCN before linking to PO');
        }

        if (collection.purchase_order_id && collection.purchase_order_id !== id) {
          throw new Error('This WCN is already linked to another purchase order');
        }

        // 3. Verify supplier matches
        if (po.supplierId !== collection.supplierId) {
          throw new Error('PO supplier must match collection order supplier');
        }

        // 4. Get collection items
        const collectionItems = await trx('collection_items')
          .where({ collectionOrderId })
          .select('*');

        if (collectionItems.length === 0) {
          throw new Error('Collection order has no items');
        }

        // 5. Update inventory from collection items (if not already done)
        for (const item of collectionItems) {
          // Check if material is composite
          const material = await trx('materials')
            .where({ id: item.materialId })
            .first();

          if (material && material.is_composite) {
            // Get composite breakdown
            const compositions = await trx('material_compositions')
              .where('composite_material_id', item.materialId)
              .where('is_active', 1);

            for (const comp of compositions) {
              // Calculate component quantity
              let componentQuantity;
              if (comp.component_type === 'container') {
                componentQuantity = item.collectedQuantity;
              } else if (comp.component_type === 'content') {
                componentQuantity = item.collectedQuantity;
              }

              // Add component to inventory
              await trx('inventory').insert({
                materialId: comp.component_material_id,
                batchNumber: `${collection.wcn_number}-${comp.component_material_id}`,
                quantity: componentQuantity,
                reservedQuantity: 0,
                averageCost: 0,
                lastPurchasePrice: 0,
                lastPurchaseDate: new Date(),
                location: 'Main Warehouse',
                condition: 'new',
                notes: `Split from composite material (Manual PO ${po.orderNumber} linked to WCN ${collection.wcn_number})`,
                minimumStockLevel: 0,
                maximumStockLevel: 0,
                isActive: true,
                created_at: new Date(),
                updated_at: new Date()
              });

              // Create transaction record
              await trx('transactions').insert({
                transactionNumber: `WCN-LINK-${Date.now()}-${item.id}-${comp.id}`,
                transactionType: 'purchase',
                referenceId: id,
                referenceType: 'purchase_order',
                materialId: comp.component_material_id,
                quantity: componentQuantity,
                amount: 0,
                transactionDate: new Date(),
                description: `Component from WCN ${collection.wcn_number} linked to Manual PO ${po.orderNumber}`,
                createdBy: userId,
                created_at: new Date(),
                updated_at: new Date()
              });
            }
          } else {
            // Regular material - add to inventory
            await trx('inventory').insert({
              materialId: item.materialId,
              batchNumber: `${collection.wcn_number}-${item.materialId}`,
              quantity: item.collectedQuantity,
              reservedQuantity: 0,
              averageCost: 0,
              lastPurchasePrice: 0,
              lastPurchaseDate: new Date(),
              location: 'Main Warehouse',
              condition: 'new',
              notes: `From Manual PO ${po.orderNumber} linked to WCN ${collection.wcn_number}`,
              minimumStockLevel: 0,
              maximumStockLevel: 0,
              isActive: true,
              created_at: new Date(),
              updated_at: new Date()
            });

            // Create transaction record
            await trx('transactions').insert({
              transactionNumber: `WCN-LINK-${Date.now()}-${item.id}`,
              transactionType: 'purchase',
              referenceId: id,
              referenceType: 'purchase_order',
              materialId: item.materialId,
              quantity: item.collectedQuantity,
              amount: item.collectedQuantity * parseFloat(item.agreedRate || 0),
              transactionDate: new Date(),
              description: `From WCN ${collection.wcn_number} linked to Manual PO ${po.orderNumber}`,
              createdBy: userId,
              created_at: new Date(),
              updated_at: new Date()
            });
          }
        }

        // 6. Link PO to collection order
        await trx('purchase_orders')
          .where({ id })
          .update({
            collection_order_id: collectionOrderId,
            status: 'received',
            notes: notes
              ? `${po.notes || ''}\n[Linked to WCN ${collection.wcn_number}] ${notes}`
              : `${po.notes || ''}\n[Linked to WCN ${collection.wcn_number}]`,
            updated_at: new Date()
          });

        // 7. Update collection order to link back to PO
        await trx('collection_orders')
          .where({ id: collectionOrderId })
          .update({
            purchase_order_id: id,
            updated_at: new Date()
          });

        auditLog('PURCHASE_ORDER_WCN_LINKED', userId, {
          purchaseOrderId: id,
          orderNumber: po.orderNumber,
          collectionOrderId,
          wcnNumber: collection.wcn_number,
          itemsCount: collectionItems.length,
          linkType: 'manual'
        });
      });

      res.json({
        success: true,
        message: 'PO successfully linked to WCN and inventory updated'
      });

    } catch (error) {
      logger.error('Error linking PO to WCN', {
        error: error.message,
        purchaseOrderId: req.params.id,
        collectionOrderId: req.body.collectionOrderId,
        userId: req.user.userId
      });
      res.status(500).json({
        success: false,
        error: error.message || 'Failed to link PO to WCN'
      });
    }
  }
);

module.exports = router;