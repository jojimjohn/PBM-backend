const express = require('express');
const { validate, validateParams, sanitize } = require('../middleware/validation');
const { requirePermission } = require('../middleware/auth');
const { logger, auditLog } = require('../utils/logger');
const { getDbConnection } = require('../config/database');
const Joi = require('joi');

const router = express.Router();

// Apply sanitization to all routes
router.use(sanitize);

// Purchase order validation schema
const purchaseOrderSchema = Joi.object({
  orderNumber: Joi.string().optional(), // Generated by backend if not provided
  supplierId: Joi.number().integer().positive().required(),
  supplierName: Joi.string().allow('').optional(), // For display purposes, not stored
  orderDate: Joi.date().default(() => new Date()),
  expectedDeliveryDate: Joi.alternatives().try(Joi.date(), Joi.string().allow('').allow(null)).optional(),
  status: Joi.string().valid('draft', 'pending', 'approved', 'sent', 'received', 'completed', 'cancelled').default('draft'),
  subtotal: Joi.number().min(0).precision(3).default(0),
  taxAmount: Joi.number().min(0).precision(3).default(0),
  totalAmount: Joi.number().min(0).precision(3).default(0),
  shippingCost: Joi.number().min(0).precision(3).default(0),
  notes: Joi.string().allow('').allow(null).optional(),
  branch_id: Joi.number().integer().positive().allow(null).optional(), // Branch ID for multi-branch support
  items: Joi.array().items(Joi.object({
    materialId: Joi.number().integer().positive().required(),
    // For drafts, quantity/rate/amount are optional; for other statuses they're required
    quantity: Joi.number().min(0.001).precision(3).optional().default(0),
    rate: Joi.number().min(0).precision(3).optional().default(0),
    amount: Joi.number().min(0).precision(3).optional().default(0)
  }).options({ stripUnknown: true })).optional()
}).options({ stripUnknown: true }).custom((value, helpers) => {
  // If not a draft, require quantity, rate, and amount for all items
  if (value.status !== 'draft' && value.items && value.items.length > 0) {
    for (const item of value.items) {
      if (!item.quantity || item.quantity <= 0) {
        return helpers.error('any.custom', { message: 'Quantity is required for non-draft orders' });
      }
      if (item.rate === undefined || item.rate === null) {
        return helpers.error('any.custom', { message: 'Rate is required for non-draft orders' });
      }
    }
  }
  return value;
});

// Purchase order item validation schema
const purchaseOrderItemSchema = Joi.object({
  purchaseOrderId: Joi.number().integer().positive().required(),
  materialId: Joi.number().integer().positive().required(),
  quantity: Joi.number().min(0.001).precision(3).required(),
  unitPrice: Joi.number().min(0).precision(3).required(),
  totalPrice: Joi.number().min(0).precision(3).required(),
  contractRate: Joi.number().min(0).precision(3).optional(),
  appliedRateType: Joi.string().valid('fixed_rate', 'discount_percentage', 'minimum_price_guarantee').optional(),
  contractSavings: Joi.number().min(0).precision(2).default(0),
  notes: Joi.string().allow('').optional()
});

// GET /api/purchase-orders - List all purchase orders
router.get('/', requirePermission('VIEW_PURCHASE'), async (req, res) => {
  try {
    const { companyId } = req.user;
    const db = getDbConnection(companyId);
    
    const {
      page = 1,
      limit = 50,
      search = '',
      supplierId = '',
      status = '',
      fromDate = '',
      toDate = ''
    } = req.query;

    const offset = (page - 1) * limit;
    
    let query = db('purchase_orders')
      .leftJoin('suppliers', 'purchase_orders.supplierId', 'suppliers.id')
      .select(
        'purchase_orders.*',
        'suppliers.name as supplierName',
        'suppliers.specialization',
        db.raw('(SELECT COUNT(*) FROM purchase_order_items WHERE purchase_order_items.purchaseOrderId = purchase_orders.id) as itemCount')
      )
      .whereNot('purchase_orders.status', 'cancelled');

    // Search filter
    if (search) {
      query = query.where(function() {
        this.where('purchase_orders.orderNumber', 'like', `%${search}%`)
            .orWhere('suppliers.name', 'like', `%${search}%`)
            .orWhere('purchase_orders.notes', 'like', `%${search}%`);
      });
    }

    // Supplier filter
    if (supplierId) {
      query = query.where('purchase_orders.supplierId', supplierId);
    }

    // Status filter
    if (status) {
      query = query.where('purchase_orders.status', status);
    }

    // Date range filter
    if (fromDate) {
      query = query.where('purchase_orders.orderDate', '>=', fromDate);
    }
    if (toDate) {
      query = query.where('purchase_orders.orderDate', '<=', toDate);
    }

    // Get total count for pagination
    const totalQuery = query.clone();
    const [{ total }] = await totalQuery.count('* as total');

    // Get paginated results
    const orders = await query
      .orderBy('purchase_orders.orderDate', 'desc')
      .orderBy('purchase_orders.id', 'desc')
      .limit(limit)
      .offset(offset);

    // Convert DECIMAL strings to numbers for consistent JSON format
    const formattedOrders = orders.map(order => ({
      ...order,
      subtotal: parseFloat(order.subtotal) || 0,
      taxAmount: parseFloat(order.taxAmount) || 0,
      totalAmount: parseFloat(order.totalAmount) || 0,
      shippingCost: parseFloat(order.shippingCost) || 0
    }));

    // Log financial values from first order for debugging
    if (formattedOrders.length > 0) {
      logger.info('ðŸ’° Sample PO financial values from list:', {
        orderNumber: formattedOrders[0].orderNumber,
        subtotal: formattedOrders[0].subtotal,
        taxAmount: formattedOrders[0].taxAmount,
        totalAmount: formattedOrders[0].totalAmount,
        shippingCost: formattedOrders[0].shippingCost
      });
    }

    auditLog('PURCHASE_ORDERS_VIEWED', req.user.userId, {
      companyId,
      count: orders.length,
      filters: { search, supplierId, status, fromDate, toDate }
    });

    res.json({
      success: true,
      data: formattedOrders,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: parseInt(total),
        pages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    logger.error('Error fetching purchase orders', { 
      error: error.message, 
      userId: req.user.userId,
      companyId: req.user.companyId
    });
    res.status(500).json({
      success: false,
      error: 'Failed to fetch purchase orders'
    });
  }
});

// GET /api/purchase-orders/:id - Get specific purchase order with items
router.get('/:id', 
  validateParams(Joi.object({ id: Joi.number().integer().positive().required() })),
  requirePermission('VIEW_PURCHASE'),
  async (req, res) => {
    try {
      const { id } = req.params;
      const { companyId } = req.user;
      const db = getDbConnection(companyId);

      // Get order details
      const order = await db('purchase_orders')
        .leftJoin('suppliers', 'purchase_orders.supplierId', 'suppliers.id')
        .select(
          'purchase_orders.*',
          'suppliers.name as supplierName',
          'suppliers.specialization',
          'suppliers.phone as supplierPhone',
          'suppliers.address as supplierAddress',
          'suppliers.contactPerson'
        )
        .where('purchase_orders.id', id)
        .first();

      if (!order) {
        return res.status(404).json({
          success: false,
          error: 'Purchase order not found'
        });
      }

      // Get order items
      logger.info(`ðŸ” Fetching items for PO ID: ${id}`);
      const items = await db('purchase_order_items')
        .leftJoin('materials', 'purchase_order_items.materialId', 'materials.id')
        .select(
          'purchase_order_items.*',
          'materials.name as materialName',
          'materials.code as materialCode',
          'materials.unit',
          'materials.category',
          'materials.standardPrice'
        )
        .where('purchase_order_items.purchaseOrderId', id)
        .orderBy('purchase_order_items.id');

      logger.info(`ðŸ“¦ Found ${items.length} items for PO #${id}`);
      logger.info(`ðŸ“‹ Items data:`, JSON.stringify(items, null, 2));

      auditLog('PURCHASE_ORDER_VIEWED', req.user.userId, {
        purchaseOrderId: id,
        orderNumber: order.orderNumber,
        supplierName: order.supplierName,
        itemsCount: items.length
      });

      // Convert DECIMAL strings to numbers for consistent JSON format
      const formattedOrder = {
        ...order,
        subtotal: parseFloat(order.subtotal) || 0,
        taxAmount: parseFloat(order.taxAmount) || 0,
        totalAmount: parseFloat(order.totalAmount) || 0,
        shippingCost: parseFloat(order.shippingCost) || 0,
        items: items.map(item => ({
          ...item,
          quantityOrdered: parseFloat(item.quantityOrdered) || 0,
          quantityReceived: parseFloat(item.quantityReceived) || 0,
          unitPrice: parseFloat(item.unitPrice) || 0,
          totalPrice: parseFloat(item.totalPrice) || 0,
          contractRate: item.contractRate ? parseFloat(item.contractRate) : null,
          contractSavings: parseFloat(item.contractSavings) || 0
        }))
      };

      logger.info(`âœ… Sending response with ${items.length} items`);
      logger.info('ðŸ’° PO financial values being sent:', {
        orderNumber: formattedOrder.orderNumber,
        subtotal: formattedOrder.subtotal,
        taxAmount: formattedOrder.taxAmount,
        totalAmount: formattedOrder.totalAmount,
        shippingCost: formattedOrder.shippingCost
      });

      res.json({
        success: true,
        data: formattedOrder
      });

    } catch (error) {
      logger.error('Error fetching purchase order', { 
        error: error.message, 
        purchaseOrderId: req.params.id,
        userId: req.user.userId
      });
      res.status(500).json({
        success: false,
        error: 'Failed to fetch purchase order'
      });
    }
  }
);

// POST /api/purchase-orders - Create new purchase order
router.post('/', 
  validate(purchaseOrderSchema),
  requirePermission('CREATE_PURCHASE'),
  async (req, res) => {
    try {
      const { companyId, userId } = req.user;
      const db = getDbConnection(companyId);

      // Extract items array and remove from order data
      const { items, supplierName, ...orderFields } = req.body;

      // Validate supplier exists
      const supplier = await db('suppliers')
        .where({ id: orderFields.supplierId })
        .first();

      if (!supplier) {
        return res.status(400).json({
          success: false,
          error: 'Supplier not found or inactive'
        });
      }

      // Generate order number if not provided
      const orderNumber = orderFields.orderNumber || `PO-${Date.now()}-${Math.floor(Math.random() * 1000)}`;

      logger.info('ðŸ’° Received financial values for PO create:', {
        subtotal: orderFields.subtotal,
        taxAmount: orderFields.taxAmount,
        totalAmount: orderFields.totalAmount,
        shippingCost: orderFields.shippingCost,
        itemsCount: items?.length || 0
      });

      // Prepare order data to match database schema
      const orderData = {
        orderNumber,
        supplierId: orderFields.supplierId,
        supplierName: supplier.name,
        supplierPhone: supplier.phone || null,
        supplierEmail: supplier.email || null,
        supplierAddress: supplier.address || null,
        orderDate: orderFields.orderDate || new Date(),
        expectedDeliveryDate: orderFields.expectedDeliveryDate || null,
        actualDeliveryDate: null,
        status: orderFields.status || 'draft',
        subtotal: parseFloat(orderFields.subtotal) || 0,
        taxAmount: parseFloat(orderFields.taxAmount) || 0,
        shippingCost: parseFloat(orderFields.shippingCost) || 0,
        totalAmount: parseFloat(orderFields.totalAmount) || 0,
        currency: 'OMR',
        deliveryAddress: orderFields.deliveryAddress || null,
        terms: `Payment Terms: ${orderFields.paymentTerms || 30} days`,
        notes: orderFields.notes || null,
        createdBy: userId,
        approvedBy: null,
        approvedAt: null,
        created_at: new Date(),
        updated_at: new Date()
      };

      logger.info('ðŸ“ Saving orderData:', {
        subtotal: orderData.subtotal,
        taxAmount: orderData.taxAmount,
        totalAmount: orderData.totalAmount,
        shippingCost: orderData.shippingCost
      });

      // Use transaction to ensure both order and items are created
      const result = await db.transaction(async (trx) => {
        // Insert purchase order
        const [orderId] = await trx('purchase_orders').insert(orderData);
        
        // Insert purchase order items if provided
        if (items && items.length > 0) {
          const itemsData = items.map(item => ({
            purchaseOrderId: orderId,
            materialId: parseInt(item.materialId),
            quantityOrdered: parseFloat(item.quantity),
            quantityReceived: 0, // Initially 0
            unitPrice: parseFloat(item.rate),
            contractRate: null, // To be populated later with contract rates
            appliedRateType: null,
            contractSavings: 0,
            totalPrice: parseFloat(item.amount),
            batchNumber: null,
            expiryDate: null,
            notes: null,
            created_at: new Date(),
            updated_at: new Date()
          }));
          
          await trx('purchase_order_items').insert(itemsData);
        }
        
        return orderId;
      });
      
      // Fetch complete order with supplier info
      const newOrder = await db('purchase_orders')
        .leftJoin('suppliers', 'purchase_orders.supplierId', 'suppliers.id')
        .select(
          'purchase_orders.*',
          'suppliers.name as supplierName'
        )
        .where('purchase_orders.id', result)
        .first();

      auditLog('PURCHASE_ORDER_CREATED', userId, {
        purchaseOrderId: result,
        orderNumber: newOrder.orderNumber,
        supplierName: newOrder.supplierName,
        totalAmount: newOrder.totalAmount,
        itemCount: items?.length || 0
      });

      logger.info('Purchase order created', {
        purchaseOrderId: result,
        orderNumber: newOrder.orderNumber,
        createdBy: userId,
        itemCount: items?.length || 0
      });

      res.status(201).json({
        success: true,
        message: 'Purchase order created successfully',
        data: newOrder
      });

    } catch (error) {
      logger.error('Error creating purchase order', { 
        error: error.message, 
        userId: req.user.userId,
        orderData: req.body
      });
      res.status(500).json({
        success: false,
        error: 'Failed to create purchase order'
      });
    }
  }
);

// PUT /api/purchase-orders/:id - Update purchase order
router.put('/:id',
  validateParams(Joi.object({ id: Joi.number().integer().positive().required() })),
  validate(purchaseOrderSchema),
  requirePermission('EDIT_PURCHASE'),
  async (req, res) => {
    try {
      const { id } = req.params;
      const { companyId, userId } = req.user;
      const db = getDbConnection(companyId);

      // Check if order exists
      const existingOrder = await db('purchase_orders')
        .where({ id })
        .first();

      if (!existingOrder) {
        return res.status(404).json({
          success: false,
          error: 'Purchase order not found'
        });
      }

      // Extract only the fields that should be updated in the database
      const {
        orderNumber,
        supplierId,
        orderDate,
        expectedDeliveryDate,
        status,
        subtotal,
        taxAmount,
        totalAmount,
        shippingCost,
        notes,
        items // Extract items for separate handling
      } = req.body;

      logger.info('ðŸ’° Received financial values for PO update:', {
        subtotal,
        taxAmount,
        totalAmount,
        shippingCost,
        itemsCount: items?.length || 0
      });

      // Update order with only valid database fields
      const updateData = {
        orderNumber,
        supplierId,
        orderDate,
        expectedDeliveryDate: expectedDeliveryDate || null,
        status,
        subtotal: parseFloat(subtotal) || 0,
        taxAmount: parseFloat(taxAmount) || 0,
        totalAmount: parseFloat(totalAmount) || 0,
        shippingCost: parseFloat(shippingCost) || 0,
        notes: notes || null,
        updated_at: new Date()
      };

      logger.info('ðŸ“ Saving updateData:', updateData);

      await db('purchase_orders')
        .where({ id })
        .update(updateData);

      // If items provided, update them
      if (items && items.length > 0) {
        // Delete existing items
        await db('purchase_order_items').where({ purchaseOrderId: id }).delete();

        // Insert new items
        const itemsData = items.map(item => ({
          purchaseOrderId: id,
          materialId: parseInt(item.materialId),
          quantityOrdered: parseFloat(item.quantity) || 0,
          quantityReceived: 0,
          unitPrice: parseFloat(item.rate) || 0,
          contractRate: null,
          appliedRateType: null,
          contractSavings: 0,
          totalPrice: parseFloat(item.amount) || (parseFloat(item.quantity) * parseFloat(item.rate)) || 0,
          batchNumber: null,
          expiryDate: null,
          notes: null,
          created_at: new Date(),
          updated_at: new Date()
        }));

        await db('purchase_order_items').insert(itemsData);
      }

      const updatedOrder = await db('purchase_orders')
        .leftJoin('suppliers', 'purchase_orders.supplierId', 'suppliers.id')
        .select(
          'purchase_orders.*',
          'suppliers.name as supplierName'
        )
        .where('purchase_orders.id', id)
        .first();

      auditLog('PURCHASE_ORDER_UPDATED', userId, {
        purchaseOrderId: id,
        orderNumber: updatedOrder.orderNumber
      });

      logger.info('Purchase order updated', {
        purchaseOrderId: id,
        orderNumber: updatedOrder.orderNumber,
        updatedBy: userId
      });

      res.json({
        success: true,
        message: 'Purchase order updated successfully',
        data: updatedOrder
      });

    } catch (error) {
      logger.error('Error updating purchase order', {
        error: error.message,
        purchaseOrderId: req.params.id,
        userId: req.user.userId
      });
      res.status(500).json({
        success: false,
        error: 'Failed to update purchase order'
      });
    }
  }
);

// POST /api/purchase-orders/:id/items - Add item to purchase order
router.post('/:id/items',
  validateParams(Joi.object({ id: Joi.number().integer().positive().required() })),
  validate(purchaseOrderItemSchema.fork('purchaseOrderId', schema => schema.optional())),
  requirePermission('CREATE_PURCHASE'),
  async (req, res) => {
    try {
      const { id } = req.params;
      const { companyId } = req.user;
      const db = getDbConnection(companyId);

      // Verify order exists and is editable
      const order = await db('purchase_orders')
        .leftJoin('suppliers', 'purchase_orders.supplierId', 'suppliers.id')
        .select(
          'purchase_orders.*',
          'suppliers.name as supplierName'
        )
        .where({ 'purchase_orders.id': id })
        .whereIn('purchase_orders.status', ['draft', 'pending'])
        .first();

      if (!order) {
        return res.status(404).json({
          success: false,
          error: 'Purchase order not found or not editable'
        });
      }

      // Verify material exists
      const material = await db('materials')
        .where({ id: req.body.materialId })
        .first();

      if (!material) {
        return res.status(400).json({
          success: false,
          error: 'Material not found or inactive'
        });
      }

      // Check for active supplier contract rates
      let contractRate = null;
      let appliedRateType = null;
      let contractSavings = 0;
      let effectiveUnitPrice = req.body.unitPrice;

      const supplierContractRate = await db('contract_rates')
        .leftJoin('contracts', 'contract_rates.contractId', 'contracts.id')
        .select(
          'contract_rates.*',
          'contracts.contractNumber',
          'contracts.endDate as contractEndDate'
        )
        .where('contracts.supplierId', order.supplierId)
        .where('contract_rates.materialId', req.body.materialId)
        .where('contracts.status', 'active')
        .where('contracts.startDate', '<=', new Date())
        .where('contracts.endDate', '>=', new Date())
        .where('contract_rates.isActive', true)
        .first();

      if (supplierContractRate) {
        // Apply contract rate based on type
        switch (supplierContractRate.rateType) {
          case 'fixed_rate':
            contractRate = supplierContractRate.contractRate;
            effectiveUnitPrice = supplierContractRate.contractRate;
            appliedRateType = 'fixed_rate';
            contractSavings = (req.body.unitPrice - supplierContractRate.contractRate) * req.body.quantity;
            break;
          
          case 'discount_percentage':
            contractRate = req.body.unitPrice * (1 - supplierContractRate.discountPercentage / 100);
            effectiveUnitPrice = contractRate;
            appliedRateType = 'discount_percentage';
            contractSavings = (req.body.unitPrice - contractRate) * req.body.quantity;
            break;
          
          case 'minimum_price_guarantee':
            contractRate = Math.min(req.body.unitPrice, supplierContractRate.contractRate);
            effectiveUnitPrice = contractRate;
            appliedRateType = 'minimum_price_guarantee';
            contractSavings = (req.body.unitPrice - contractRate) * req.body.quantity;
            break;
        }

        logger.info('Applied supplier contract rate', {
          purchaseOrderId: id,
          supplierId: order.supplierId,
          materialId: req.body.materialId,
          rateType: supplierContractRate.rateType,
          originalPrice: req.body.unitPrice,
          contractPrice: contractRate,
          savings: contractSavings
        });
      }

      const itemData = {
        ...req.body,
        purchaseOrderId: id,
        unitPrice: effectiveUnitPrice,
        totalPrice: effectiveUnitPrice * req.body.quantity,
        contractRate: contractRate,
        appliedRateType: appliedRateType,
        contractSavings: Math.max(0, contractSavings), // Ensure non-negative savings
        created_at: new Date(),
        updated_at: new Date()
      };

      const [itemId] = await db('purchase_order_items').insert(itemData);
      
      // Update order totals
      const orderItems = await db('purchase_order_items')
        .where({ purchaseOrderId: id })
        .select(db.raw('SUM(totalPrice) as subtotal'));

      const subtotal = orderItems[0].subtotal || 0;
      const taxAmount = subtotal * 0.05; // 5% tax
      const totalAmount = subtotal + taxAmount + (order.shippingCost || 0) - (order.discountAmount || 0);

      await db('purchase_orders')
        .where({ id })
        .update({
          subtotal,
          taxAmount,
          totalAmount,
          updated_at: new Date()
        });

      const newItem = await db('purchase_order_items')
        .leftJoin('materials', 'purchase_order_items.materialId', 'materials.id')
        .select(
          'purchase_order_items.*',
          'materials.name as materialName',
          'materials.code as materialCode'
        )
        .where('purchase_order_items.id', itemId)
        .first();

      auditLog('PURCHASE_ORDER_ITEM_ADDED', req.user.userId, {
        purchaseOrderId: id,
        itemId,
        materialName: newItem.materialName,
        quantity: newItem.quantity,
        totalPrice: newItem.totalPrice,
        contractApplied: !!contractRate,
        appliedRateType: appliedRateType,
        contractSavings: contractSavings
      });

      res.status(201).json({
        success: true,
        message: 'Item added to purchase order successfully',
        data: newItem
      });

    } catch (error) {
      logger.error('Error adding purchase order item', { 
        error: error.message, 
        purchaseOrderId: req.params.id,
        userId: req.user.userId,
        itemData: req.body
      });
      res.status(500).json({
        success: false,
        error: 'Failed to add purchase order item'
      });
    }
  }
);

// PUT /api/purchase-orders/:id/receive - Receive purchase order (update inventory)
router.put('/:id/receive',
  validateParams(Joi.object({ id: Joi.number().integer().positive().required() })),
  validate(Joi.object({
    receivedItems: Joi.array().items(
      Joi.object({
        itemId: Joi.number().integer().positive().required(),
        receivedQuantity: Joi.number().min(0).precision(3).required(),
        contentQuantity: Joi.number().min(0).precision(3).optional(), // For composite materials
        batchNumber: Joi.string().max(100).allow('').optional(),
        expiryDate: Joi.date().optional(),
        condition: Joi.string().valid('new', 'used', 'refurbished', 'damaged').default('new'),
        location: Joi.string().max(100).allow('').optional()
      })
    ).required(),
    notes: Joi.string().allow('').optional()
  })),
  requirePermission('EDIT_PURCHASE'),
  async (req, res) => {
    try {
      const { id } = req.params;
      const { receivedItems, notes } = req.body;
      const { companyId } = req.user;
      const db = getDbConnection(companyId);

      const order = await db('purchase_orders')
        .where({ id, status: 'approved' })
        .first();

      if (!order) {
        return res.status(404).json({
          success: false,
          error: 'Purchase order not found or not ready for receiving'
        });
      }

      await db.transaction(async (trx) => {
        for (const receivedItem of receivedItems) {
          // Get the order item details
          const orderItem = await trx('purchase_order_items')
            .where({ id: receivedItem.itemId, purchaseOrderId: id })
            .first();

          if (!orderItem) continue;

          // Check if this material is composite
          const compositions = await trx('material_compositions')
            .leftJoin('materials', 'material_compositions.component_material_id', 'materials.id')
            .select(
              'material_compositions.*',
              'materials.name as component_material_name',
              'materials.code as component_material_code'
            )
            .where('material_compositions.composite_material_id', orderItem.materialId)
            .where('material_compositions.is_active', 1);

          const isComposite = compositions.length > 0;

          if (isComposite) {
            // This is a composite material - split into components
            const breakdown = {
              composite_material_id: orderItem.materialId,
              composite_quantity: receivedItem.receivedQuantity,
              content_quantity: receivedItem.contentQuantity || null,
              split_date: new Date(),
              components: []
            };

            for (const composition of compositions) {
              // Calculate component quantity based on type
              let componentQuantity;
              if (composition.component_type === 'container') {
                // Containers = number of composite units (drums, boxes, etc.)
                componentQuantity = receivedItem.receivedQuantity;
              } else if (composition.component_type === 'content') {
                // Content = actual quantity provided (or use composite quantity as fallback)
                componentQuantity = receivedItem.contentQuantity || receivedItem.receivedQuantity;
              }

              // Add component to inventory
              await trx('inventory').insert({
                materialId: composition.component_material_id,
                batchNumber: receivedItem.batchNumber || `PO-${order.orderNumber}-${Date.now()}`,
                quantity: componentQuantity,
                reservedQuantity: 0,
                averageCost: 0, // Components don't have individual cost
                lastPurchasePrice: 0,
                lastPurchaseDate: new Date(),
                expiryDate: receivedItem.expiryDate,
                location: receivedItem.location || 'Main Warehouse',
                condition: receivedItem.condition,
                notes: `Split from composite material (PO ${order.orderNumber})`,
                minimumStockLevel: 0,
                maximumStockLevel: 0,
                isActive: true,
                created_at: new Date(),
                updated_at: new Date()
              });

              // Create transaction record for component
              await trx('transactions').insert({
                transactionNumber: `SPLIT-${Date.now()}-${orderItem.id}-${composition.id}`,
                transactionType: 'purchase',
                referenceId: id,
                referenceType: 'purchase_order',
                materialId: composition.component_material_id,
                quantity: componentQuantity,
                amount: 0, // No separate cost for components
                transactionDate: new Date(),
                description: `Component from ${composition.component_type} - PO ${order.orderNumber}`,
                createdBy: req.user.userId,
                created_at: new Date(),
                updated_at: new Date()
              });

              breakdown.components.push({
                material_id: composition.component_material_id,
                material_name: composition.component_material_name,
                material_code: composition.component_material_code,
                component_type: composition.component_type,
                capacity: composition.capacity,
                capacity_unit: composition.capacity_unit,
                total_quantity: componentQuantity
              });
            }

            // Mark order item as composite and store breakdown
            await trx('purchase_order_items')
              .where({ id: receivedItem.itemId })
              .update({
                is_composite_material: 1,
                composite_breakdown: JSON.stringify(breakdown),
                updated_at: new Date()
              });

            logger.info('Composite material split', {
              orderId: id,
              orderNumber: order.orderNumber,
              compositeMaterialId: orderItem.materialId,
              compositeQuantity: receivedItem.receivedQuantity,
              componentsCount: compositions.length,
              breakdown
            });

          } else {
            // Regular material - add to inventory as-is
            await trx('inventory').insert({
              materialId: orderItem.materialId,
              batchNumber: receivedItem.batchNumber || `PO-${order.orderNumber}-${Date.now()}`,
              quantity: receivedItem.receivedQuantity,
              reservedQuantity: 0,
              averageCost: orderItem.unitPrice,
              lastPurchasePrice: orderItem.unitPrice,
              lastPurchaseDate: new Date(),
              expiryDate: receivedItem.expiryDate,
              location: receivedItem.location || 'Main Warehouse',
              condition: receivedItem.condition,
              notes: `Received from PO ${order.orderNumber}`,
              minimumStockLevel: 0,
              maximumStockLevel: 0,
              isActive: true,
              created_at: new Date(),
              updated_at: new Date()
            });

            // Create transaction record
            await trx('transactions').insert({
              transactionNumber: `PURCHASE-${Date.now()}-${orderItem.id}`,
              transactionType: 'purchase',
              referenceId: id,
              referenceType: 'purchase_order',
              materialId: orderItem.materialId,
              quantity: receivedItem.receivedQuantity,
              amount: receivedItem.receivedQuantity * orderItem.unitPrice,
              transactionDate: new Date(),
              description: `Purchase received - Order ${order.orderNumber}`,
              createdBy: req.user.userId,
              created_at: new Date(),
              updated_at: new Date()
            });
          }
        }

        // Update purchase order status
        await trx('purchase_orders')
          .where({ id })
          .update({
            status: 'received',
            notes: notes ? `${order.notes || ''}\nReceived: ${notes}` : order.notes,
            updated_at: new Date()
          });
      });

      auditLog('PURCHASE_ORDER_RECEIVED', req.user.userId, {
        purchaseOrderId: id,
        orderNumber: order.orderNumber,
        itemsReceived: receivedItems.length
      });

      res.json({
        success: true,
        message: 'Purchase order received successfully and inventory updated'
      });

    } catch (error) {
      logger.error('Error receiving purchase order', { 
        error: error.message, 
        purchaseOrderId: req.params.id,
        userId: req.user.userId
      });
      res.status(500).json({
        success: false,
        error: 'Failed to receive purchase order'
      });
    }
  }
);

// POST /api/purchase-orders/:id/approve - Approve a purchase order
router.post('/:id/approve',
  validateParams(Joi.object({
    id: Joi.number().integer().positive().required()
  })),
  validate(Joi.object({
    approvalNotes: Joi.string().allow('').optional(),
    approvedAmount: Joi.number().min(0).precision(3).optional()
  })),
  requirePermission('APPROVE_PURCHASE'),
  async (req, res) => {
    try {
      const { id } = req.params;
      const { approvalNotes, approvedAmount } = req.body;
      const { companyId, userId } = req.user;
      const db = getDbConnection(companyId);

      const order = await db('purchase_orders')
        .where({ id, status: 'draft' })
        .first();

      if (!order) {
        return res.status(404).json({
          success: false,
          error: 'Purchase order not found or not ready for approval'
        });
      }

      await db('purchase_orders')
        .where({ id })
        .update({
          status: 'approved',
          approvedBy: userId,
          approvedAt: new Date(),
          notes: approvalNotes ? `${order.notes || ''}\nApproval: ${approvalNotes}` : order.notes,
          updated_at: new Date()
        });

      auditLog('PURCHASE_ORDER_APPROVED', userId, {
        purchaseOrderId: id,
        orderNumber: order.orderNumber,
        originalAmount: order.totalAmount,
        approvedAmount: approvedAmount || order.totalAmount,
        approvalNotes
      });

      res.json({
        success: true,
        message: 'Purchase order approved successfully'
      });

    } catch (error) {
      logger.error('Error approving purchase order', { 
        error: error.message, 
        purchaseOrderId: req.params.id,
        userId: req.user.userId
      });
      res.status(500).json({
        success: false,
        error: 'Failed to approve purchase order'
      });
    }
  }
);

// PATCH /api/purchase-orders/:id/status - Update purchase order status
router.patch('/:id/status',
  validateParams(Joi.object({
    id: Joi.number().integer().positive().required()
  })),
  validate(Joi.object({
    status: Joi.string().valid('draft', 'pending', 'approved', 'sent', 'received', 'completed', 'cancelled').required(),
    notes: Joi.string().allow('').optional()
  })),
  requirePermission('EDIT_PURCHASE'),
  async (req, res) => {
    try {
      const { id } = req.params;
      const { status, notes } = req.body;
      const { companyId, userId } = req.user;
      const db = getDbConnection(companyId);

      const order = await db('purchase_orders')
        .where({ id })
        .first();

      if (!order) {
        return res.status(404).json({
          success: false,
          error: 'Purchase order not found'
        });
      }

      // Validate status transitions
      const validTransitions = {
        'draft': ['pending', 'approved', 'cancelled'],
        'pending': ['approved', 'cancelled'],
        'approved': ['sent', 'cancelled'],
        'sent': ['received', 'cancelled'],
        'received': ['completed'],
        'completed': [], // Final state
        'cancelled': [] // Final state
      };

      if (!validTransitions[order.status]?.includes(status)) {
        return res.status(400).json({
          success: false,
          error: `Cannot change status from ${order.status} to ${status}`
        });
      }

      const updateData = {
        status: status,
        updated_at: new Date()
      };

      if (notes) {
        updateData.notes = order.notes ? `${order.notes}\nStatus Update: ${notes}` : notes;
      }

      // Add status-specific fields
      if (status === 'sent') {
        updateData.sentAt = new Date();
        updateData.sentBy = userId;
      } else if (status === 'cancelled') {
        updateData.cancelledAt = new Date();
        updateData.cancelledBy = userId;
      }

      await db('purchase_orders')
        .where({ id })
        .update(updateData);

      auditLog('PURCHASE_ORDER_STATUS_CHANGED', userId, {
        purchaseOrderId: id,
        orderNumber: order.orderNumber,
        fromStatus: order.status,
        toStatus: status,
        notes
      });

      res.json({
        success: true,
        message: `Purchase order status updated to ${status} successfully`
      });

    } catch (error) {
      logger.error('Error updating purchase order status', { 
        error: error.message, 
        purchaseOrderId: req.params.id,
        userId: req.user.userId
      });
      res.status(500).json({
        success: false,
        error: 'Failed to update purchase order status'
      });
    }
  }
);

// GET /api/purchase-orders/pending - Get pending purchase orders for approval
router.get('/pending', 
  requirePermission('VIEW_PURCHASE'),
  async (req, res) => {
    try {
      const { companyId } = req.user;
      const db = getDbConnection(companyId);
      
      const pendingOrders = await db('purchase_orders')
        .leftJoin('suppliers', 'purchase_orders.supplierId', 'suppliers.id')
        .select(
          'purchase_orders.*',
          'suppliers.name as supplierName',
          'suppliers.contactPerson as supplierContact'
        )
        .where('purchase_orders.status', 'draft')
        .orderBy('purchase_orders.created_at', 'desc');

      res.json({
        success: true,
        data: pendingOrders,
        message: 'Pending purchase orders retrieved successfully'
      });

    } catch (error) {
      logger.error('Error fetching pending purchase orders', { 
        error: error.message, 
        userId: req.user.userId,
        companyId: req.user.companyId
      });
      res.status(500).json({
        success: false,
        error: 'Failed to fetch pending purchase orders'
      });
    }
  }
);

// GET /api/purchase-orders/contract-rate/:supplierId/:materialId - Get contract rate for supplier and material
router.get('/contract-rate/:supplierId/:materialId',
  validateParams(Joi.object({ 
    supplierId: Joi.number().integer().positive().required(),
    materialId: Joi.number().integer().positive().required()
  })),
  requirePermission('VIEW_PURCHASE'),
  async (req, res) => {
    try {
      const { supplierId, materialId } = req.params;
      const { companyId } = req.user;
      const db = getDbConnection(companyId);

      // Get material standard price
      const material = await db('materials')
        .select('standardPrice', 'name', 'code', 'unit')
        .where('id', materialId)
        .first();

      if (!material) {
        return res.status(404).json({
          success: false,
          error: 'Material not found'
        });
      }

      // Get active contract rate for this material and supplier
      const contractRate = await db('contract_rates')
        .leftJoin('contracts', 'contract_rates.contractId', 'contracts.id')
        .select(
          'contract_rates.*',
          'contracts.contractNumber',
          'contracts.endDate as contractEndDate'
        )
        .where('contracts.supplierId', supplierId)
        .where('contract_rates.materialId', materialId)
        .where('contracts.status', 'active')
        .where('contracts.startDate', '<=', new Date())
        .where('contracts.endDate', '>=', new Date())
        .where('contract_rates.isActive', true)
        .first();

      if (!contractRate) {
        return res.json({
          success: true,
          data: {
            hasContractRate: false,
            standardPrice: material.standardPrice,
            effectivePrice: material.standardPrice,
            material
          }
        });
      }

      // Calculate effective price based on contract type
      let effectivePrice = material.standardPrice;
      let savings = 0;
      let savingsPercentage = 0;

      switch (contractRate.rateType) {
        case 'fixed_rate':
          effectivePrice = contractRate.contractRate;
          savings = material.standardPrice - contractRate.contractRate;
          savingsPercentage = material.standardPrice > 0 ? (savings / material.standardPrice) * 100 : 0;
          break;
        
        case 'discount_percentage':
          effectivePrice = material.standardPrice * (1 - contractRate.discountPercentage / 100);
          savings = material.standardPrice - effectivePrice;
          savingsPercentage = contractRate.discountPercentage;
          break;
        
        case 'minimum_price_guarantee':
          effectivePrice = Math.min(material.standardPrice, contractRate.contractRate);
          savings = material.standardPrice - effectivePrice;
          savingsPercentage = material.standardPrice > 0 ? (savings / material.standardPrice) * 100 : 0;
          break;
      }

      res.json({
        success: true,
        data: {
          hasContractRate: true,
          standardPrice: material.standardPrice,
          effectivePrice: parseFloat(effectivePrice.toFixed(3)),
          savings: parseFloat(savings.toFixed(3)),
          savingsPercentage: parseFloat(savingsPercentage.toFixed(2)),
          contractRate,
          material,
          isExpiringSoon: new Date(contractRate.contractEndDate) < new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
        }
      });

    } catch (error) {
      logger.error('Error fetching purchase contract rate', { 
        error: error.message, 
        supplierId: req.params.supplierId,
        materialId: req.params.materialId,
        userId: req.user.userId
      });
      res.status(500).json({
        success: false,
        error: 'Failed to fetch purchase contract rate'
      });
    }
  }
);

module.exports = router;